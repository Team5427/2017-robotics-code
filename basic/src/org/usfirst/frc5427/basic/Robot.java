// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc5427.basic;

import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.IterativeRobot;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.command.Scheduler;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj.SPI;
import edu.wpi.first.wpilibj.Timer;

import org.usfirst.frc5427.basic.commands.*;
import org.usfirst.frc5427.basic.subsystems.*;

import com.kauailabs.navx.frc.AHRS;

/**
 * The VM is configured to automatically run this class, and to call the
 * functions corresponding to each mode, as described in the IterativeRobot
 * documentation. If you change the name of this class or the package after
 * creating this project, you must also update the manifest file in the resource
 * directory.
 */
public class Robot extends IterativeRobot implements PIDOutput {

	Command autonomousCommand;

	public static OI oi;
	public static DriveTrain driveTrain;

	/**
	 * This function is run when the robot is first started up and should be
	 * used for any initialization code.
	 */

	public static AHRS ahrs;
	public static PIDController turnControllerStraight;
	public static PIDController turnControllerRotate;

	static double kPS = 5f;
	static double kIS = 1f;
	static double kDS = 0.01;
	static double kFS = 0.00;

	static double kPR = 5f;
	static double kIR = 1f;
	static double kDR = 0.01;
	static double kFR = 0.00;
	
	static double kToleranceDegrees = 0f;
	double rotateToAngleRate = 0;
	
	public float startFusedHeading = 0;
	public long startTime;

	public void robotInit() {
		RobotMap.init();
		driveTrain = new DriveTrain();

		try {

			/* Communicate w/navX-MXP via the MXP SPI Bus. */
			/*
			 * Alternatively: I2C.Port.kMXP, SerialPort.Port.kMXP or
			 * SerialPort.Port.kUSB
			 */
			/*
			 * See
			 * http://navx-mxp.kauailabs.com/guidance/selecting-an-interface/
			 * for details.
			 */
			ahrs = new AHRS(SPI.Port.kMXP) {
				@Override
				public double pidGet() {
					return getFusedHeading();
				}
			};

		} catch (RuntimeException ex) {
			DriverStation.reportError("Error instantiating navX-MXP: " + ex.getMessage(),true);
		}

		turnControllerStraight = new PIDController(kPS, kIS, kDS, kFS, ahrs, this);
		turnControllerStraight.setInputRange(-180.0f, 180.0f);
		turnControllerStraight.setOutputRange(-1.0, 1.0);
		turnControllerStraight.setAbsoluteTolerance(kToleranceDegrees);
		turnControllerStraight.setContinuous(true);
		
		turnControllerRotate = new PIDController(kPR,kIR,kDR,kFR,ahrs,this);
		turnControllerRotate.setInputRange(-180.0f,180.0f);
		turnControllerRotate.setOutputRange(-1.0,1.0);
		turnControllerRotate.setAbsoluteTolerance(kToleranceDegrees);
		turnControllerRotate.setContinuous(true);

		SmartDashboard.putNumber("Straight P", kPS);
		SmartDashboard.putNumber("Straight I", kIS);
		SmartDashboard.putNumber("Straight D", kDS);
		SmartDashboard.putNumber("Straight F", kFS);
		SmartDashboard.putNumber("Rotate P", kPR);
		SmartDashboard.putNumber("Rotate I", kIR);
		SmartDashboard.putNumber("Rotate D", kDR);
		SmartDashboard.putNumber("Rotate F", kFR);
		SmartDashboard.putNumber("Tolerance", kToleranceDegrees);

		// OI must be constructed after subsystems. If the OI creates Commands
		// (which it very likely will), subsystems are not guaranteed to bet
		// constructed yet. Thus, their requires() statements may grab null
		// pointers. Bad news. Don't move it.
		oi = new OI();

		autonomousCommand = new AutonomousCommand();
	}

	/**
	 * This function is called when the disabled button is hit. You can use it
	 * to reset subsystems before shutting down.
	 */
	public void disabledInit() {

	}

	public void disabledPeriodic() {
		Scheduler.getInstance().run();
	}


	public void autonomousInit() {
		turnControllerStraight.setPID(SmartDashboard.getNumber("p", kPS), SmartDashboard.getNumber("i", kIS),SmartDashboard.getNumber("d", kDS), SmartDashboard.getNumber("f", kFS));

		// schedule the autonomous command (example)
		startTime = System.nanoTime();
		startFusedHeading = ahrs.getFusedHeading();
		
		// TODO remove comment on ahrs.reset();

		turnControllerStraight.enable();
		turnControllerRotate.disable();
		turnControllerStraight.setSetpoint(ahrs.getFusedHeading() - 360);
		turnControllerRotate.setSetpoint(-90);
	}

	/**
	 * This function is called periodically during autonomous
	 */

	public void autonomousPeriodic() {
		Scheduler.getInstance().run();
		driveTrain.robotDrive41.setSafetyEnabled(true);
		double currentRotationRate = rotateToAngleRate;

		try {
			/* Use the joystick X axis for lateral movement, */
			/* Y axis for forward movement, and the current */
			/* calculated rotation rate (or joystick Z axis), */
			/* depending upon whether "rotate to angle" is active. */

			if (2.3 > ((System.nanoTime() - startTime) / 1000000000f)) {
				driveTrain.robotDrive41.drive(-.3, ahrs.getFusedHeading());

				//SmartDashboard.putBoolean("isConnected", ahrs.isConnected());
				//SmartDashboard.putNumber("CompassHeading", ahrs.getCompassHeading());
				SmartDashboard.putNumber("How much did Robot move?: ", ahrs.getFusedHeading() - startFusedHeading);
				SmartDashboard.putNumber("Angle", ahrs.getYaw());
				SmartDashboard.putNumber("fusedHeading", ahrs.getFusedHeading());
				//SmartDashboard.putBoolean("isCalibrating", ahrs.isCalibrating());
				//SmartDashboard.putString("FirmwareVersion", ahrs.getFirmwareVersion());
				//SmartDashboard.putNumber("UpdateCount", ahrs.getUpdateCount());
				SmartDashboard.putNumber("FrontLeft", RobotMap.driveTrainFrontLeftMotor.get());
				SmartDashboard.putNumber("FrontRight", RobotMap.driveTrainFrontRightMotor.get());
				SmartDashboard.putNumber("RearLeft", RobotMap.driveTrainRearLeftMotor.get());
				SmartDashboard.putNumber("RearRight", RobotMap.driveTrainRearRightMotor.get());
				SmartDashboard.putNumber("Yaw", ahrs.getYaw());
				SmartDashboard.putNumber("SetPoint", turnControllerStraight.getSetpoint());
			
			} 
			else if (5 > ((System.nanoTime() - startTime) / 1000000000f)) {
				//driveTrain.robotDrive41.drive(rotateToAngleRate, 90);
				if(turnControllerStraight.isEnabled())
				{
					turnControllerStraight.disable();
					turnControllerRotate.enable();
				}
				driveTrain.robotDrive41.arcadeDrive(0,currentRotationRate);
			}

		} catch (RuntimeException ex) {
			DriverStation.reportError("Error communicating with drive system: ", true);
		}
		Timer.delay(0.005); // wait for a motor update time
	}

	public void teleopInit() {
		// This makes sure that the autonomous stops running when
		// teleop starts running. If you want the autonomous to
		// continue until interrupted by another command, remove
		// this line or comment it out.
		if (autonomousCommand != null)
			autonomousCommand.cancel();
	}

	/**
	 * This function is called periodically during operator control
	 */
	public void teleopPeriodic() {
		Scheduler.getInstance().run();

	}

	/**
	 * This function is called periodically during test mode
	 */
	public void testPeriodic() {
		LiveWindow.run();
	}

	@Override
	public void pidWrite(double output) {
		// TODO Auto-generated method stub

		rotateToAngleRate = output;

	}
}
