// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc5427.basic;

import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.IterativeRobot;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.command.Scheduler;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj.SPI;
import edu.wpi.first.wpilibj.Sendable;
import edu.wpi.first.wpilibj.Talon;
import edu.wpi.first.wpilibj.Timer;

import org.usfirst.frc5427.basic.commands.*;
import org.usfirst.frc5427.basic.subsystems.*;

import com.kauailabs.navx.frc.AHRS;

/**
 * The VM is configured to automatically run this class, and to call the
 * functions corresponding to each mode, as described in the IterativeRobot
 * documentation. If you change the name of this class or the package after
 * creating this project, you must also update the manifest file in the resource
 * directory.
 */
public class Robot extends IterativeRobot implements PIDOutput {

	Command autonomousCommand;

	public static OI oi;
	public static DriveTrain driveTrain;

	/**
	 * This function is run when the robot is first started up and should be
	 * used for any initialization code.
	 */

	public static AHRS ahrs;
	public static PIDController turnControllerStraight;
	public static PIDController turnControllerRotate;
	public int autoFinished;

	static double kPS = .003;
	static double kIS = 0f;
	static double kDS = 0f;
	//static double kFS = 0.00;

	static double kPR = .02;
	static double kIR = 0f;
	static double kDR = 0f;
	//static double kFR = 0f;
	
	static double kToleranceDegrees = 0f;
	double rotateToAngleRate = 0;
	
	public float startYaw = 0;
	public long startTime;

	public void robotInit() {
		RobotMap.init();
		driveTrain = new DriveTrain();

		try {

			/* Communicate w/navX-MXP via the MXP SPI Bus. */
			/*
			 * Alternatively: I2C.Port.kMXP, SerialPort.Port.kMXP or
			 * SerialPort.Port.kUSB
			 */
			/*
			 * See
			 * http://navx-mxp.kauailabs.com/guidance/selecting-an-interface/
			 * for details.
			 */
			ahrs = new AHRS(SPI.Port.kMXP) {
				@Override
				public double pidGet() {
					return getYaw();
				}
			};

		} catch (RuntimeException ex) {
			DriverStation.reportError("Error instantiating navX-MXP: " + ex.getMessage(),true);
		}

		turnControllerStraight = new PIDController(kPS, kIS, kDS, ahrs, this);
		turnControllerStraight.setInputRange(-180.0f, 180.0f);
		turnControllerStraight.setOutputRange(-1.0, 1.0);
		turnControllerStraight.setAbsoluteTolerance(kToleranceDegrees);
		turnControllerStraight.setContinuous(true);
		
		turnControllerRotate = new PIDController(kPR,kIR,kDR,ahrs,this);
		turnControllerRotate.setInputRange(-180.0f,180.0f);
		turnControllerRotate.setOutputRange(-1.0,1.0);
		turnControllerRotate.setAbsoluteTolerance(kToleranceDegrees);
		turnControllerRotate.setContinuous(true);

//		SmartDashboard.putNumber("Straight P", kPS);
//		SmartDashboard.putNumber("Straight I", kIS);
//		SmartDashboard.putNumber("Straight D", kDS);
////		SmartDashboard.putNumber("Straight F", kFS);
//		SmartDashboard.putNumber("Rotate P", kPR);
//		SmartDashboard.putNumber("Rotate I", kIR);
//		SmartDashboard.putNumber("Rotate D", kDR);
////		SmartDashboard.putNumber("Rotate F", kFR);
//		SmartDashboard.putNumber("Tolerance", kToleranceDegrees);

		// OI must be constructed after subsystems. If the OI creates Commands
		// (which it very likely will), subsystems are not guaranteed to bet
		// constructed yet. Thus, their requires() statements may grab null
		// pointers. Bad news. Don't move it.
	

		autonomousCommand = new AutonomousCommand();
		autoFinished = 0;
//		SmartDashboard.putNumber("How much did Robot move?: ", ahrs.getFusedHeading() - startFusedHeading);
//		SmartDashboard.putNumber("Angle", ahrs.getYaw());
//		SmartDashboard.putNumber("fusedHeading", ahrs.getFusedHeading());
//		//SmartDashboard.putBoolean("isCalibrating", ahrs.isCalibrating());
//		//SmartDashboard.putString("FirmwareVersion", ahrs.getFirmwareVersion());
//		//SmartDashboard.putNumber("UpdateCount", ahrs.getUpdateCount());
//		SmartDashboard.putNumber("FrontLeft", RobotMap.driveTrainFrontLeftMotor.get());
//		SmartDashboard.putNumber("FrontRight", RobotMap.driveTrainFrontRightMotor.get());
//		SmartDashboard.putNumber("RearLeft", RobotMap.driveTrainRearLeftMotor.get());
//		SmartDashboard.putNumber("RearRight", RobotMap.driveTrainRearRightMotor.get());
//		SmartDashboard.putNumber("Yaw", ahrs.getYaw());
//		SmartDashboard.putNumber("SetPoint", turnControllerStraight.getSetpoint());
//		SmartDashboard.putNumber("AutoFinished", autoFinished);
		oi = new OI();
	}

	/**
	 * This function is called when the disabled button is hit. You can use it
	 * to reset subsystems before shutting down.
	 */
	public void disabledInit() {

	}

	public void disabledPeriodic() {
		Scheduler.getInstance().run();
	}


	public void autonomousInit() {
	//	turnControllerStraight.setPID(SmartDashboard.getNumber("p", kPS), SmartDashboard.getNumber("i", kIS),SmartDashboard.getNumber("d", kDS));

		// schedule the autonomous command (example)
		startTime = System.nanoTime();
		startYaw = ahrs.getYaw();
		
		 ahrs.reset();

		turnControllerStraight.enable();
		turnControllerRotate.disable();
		turnControllerStraight.setSetpoint(ahrs.getYaw());
		turnControllerRotate.setSetpoint(90);
	}

	/**
	 * This function is called periodically during autonomous
	 */

	public void autonomousPeriodic() {
		Scheduler.getInstance().run();
		driveTrain.robotDrive41.setSafetyEnabled(true);
		double currentRotationRate = rotateToAngleRate;

		try {
			/* Use the joystick X axis for lateral movement, */
			/* Y axis for forward movement, and the current */
			/* calculated rotation rate (or joystick Z axis), */
			/* depending upon whether "rotate to angle" is active. */
			//SmartDashboard.putBoolean("isConnected", ahrs.isConnected());
			//SmartDashboard.putNumber("CompassHeading", ahrs.getCompassHeading());
			
			
		//	turnControllerStraight.updateTable();
			//SmartDashboard.putData("Table for PID", (Sendable) turnControllerStraight.getTable());

		//	LiveWindow.addActuator("DriveTrain", "TurnControllerStraight", turnControllerStraight);
			//LiveWindow.run();

			if (2.3 > ((System.nanoTime() - startTime) / 1000000000f)) {
				driveTrain.robotDrive41.drive(-.3, ahrs.getFusedHeading());
				} 
			else if (3.8 > ((System.nanoTime() - startTime) / 1000000000f)) {
				//driveTrain.robotDrive41.drive(rotateToAngleRate, 90);
				if(turnControllerStraight.isEnabled())
				{
					turnControllerStraight.disable();
					turnControllerRotate.enable();
				}
				driveTrain.robotDrive41.arcadeDrive(0,currentRotationRate);
				
			}

		} catch (RuntimeException ex) {
			DriverStation.reportError("Error communicating with drive system: ", true);
		}
		Timer.delay(0.005); // wait for a motor update time
	}

	public void teleopInit() {
		// This makes sure that the autonomous stops running when
		// teleop starts running. If you want the autonomous to
		// continue until interrupted by another command, remove
		// this line or comment it out.
		if (autonomousCommand != null)
			autonomousCommand.cancel();
	}

	/**
	 * This function is called periodically during operator control
	 */
	public void teleopPeriodic() {
		Scheduler.getInstance().run();

	}

	/**
	 * This function is called periodically during test mode
	 */
	public void testPeriodic() {
		Scheduler.getInstance().run();
		driveTrain.robotDrive41.setSafetyEnabled(true);
		double currentRotationRate = rotateToAngleRate;
		double move=ahrs.getYaw() - startYaw;

		try {
			/* Use the joystick X axis for lateral movement, */
			/* Y axis for forward movement, and the current */
			/* calculated rotation rate (or joystick Z axis), */
			/* depending upon whether "rotate to angle" is active. */
			//SmartDashboard.putBoolean("isConnected", ahrs.isConnected());
			//SmartDashboard.putNumber("CompassHeading", ahrs.getCompassHeading());
			
			SmartDashboard.putNumber("Angle", ahrs.getYaw());
			SmartDashboard.putNumber("fusedHeading", ahrs.getFusedHeading());
			SmartDashboard.putNumber("How much did Robot move?: ",move);
			//SmartDashboard.putBoolean("isCalibrating", ahrs.isCalibrating());
			//SmartDashboard.putString("FirmwareVersion", ahrs.getFirmwareVersion());
			//SmartDashboard.putNumber("UpdateCount", ahrs.getUpdateCount());
			SmartDashboard.putNumber("FrontLeft", RobotMap.driveTrainFrontLeftMotor.get());
			SmartDashboard.putNumber("FrontRight", RobotMap.driveTrainFrontRightMotor.get());
			SmartDashboard.putNumber("RearLeft", RobotMap.driveTrainRearLeftMotor.get());
			SmartDashboard.putNumber("RearRight", RobotMap.driveTrainRearRightMotor.get());
			SmartDashboard.putNumber("Yaw", ahrs.getYaw());
			SmartDashboard.putNumber("SetPoint", turnControllerStraight.getSetpoint());
			
			SmartDashboard.putNumber("Rotate SetPoint",turnControllerRotate.getSetpoint());
			SmartDashboard.putNumber("PIDOutputRotate", rotateToAngleRate);
			SmartDashboard.putNumber("PIDInputRotate", ahrs.getFusedHeading());
			SmartDashboard.putNumber("AutoFinished", autoFinished);
			
	//		turnControllerStraight.updateTable();
			//	SmartDashboard.putData("Table for PID", (Sendable) turnControllerStraight.getTable());
		
		
			
			
//			LiveWindow.addActuator("DriveTrain", "TurnControllerStraight", turnControllerStraight);
			

			if (2.3 > ((System.nanoTime() - startTime) / 1000000000f)) {
				driveTrain.robotDrive41.arcadeDrive(-.4, -currentRotationRate);
				move = ahrs.getYaw() - startYaw;
				} 
			else if (5.3 > ((System.nanoTime() - startTime) / 1000000000f)) {
				//driveTrain.robotDrive41.drive(rotateToAngleRate, 90);
				if(turnControllerStraight.isEnabled())
				{
					turnControllerStraight.disable();
					turnControllerRotate.enable();
				}
				
				driveTrain.robotDrive41.arcadeDrive(0,-currentRotationRate);
			}
			else if (5.8 > ((System.nanoTime() - startTime) / 1000000000f)) {
				driveTrain.robotDrive41.arcadeDrive(-.3, -currentRotationRate);
				move = ahrs.getYaw() - startYaw;
			
				} 
			else
			{
				driveTrain.stop();
				turnControllerRotate.disable();
				autoFinished=1;
			}
		
			
			
		//	LiveWindow.run();

		} catch (RuntimeException ex) {
			DriverStation.reportError("Error communicating with drive system: "+ex.getMessage(), true);
			ex.printStackTrace();
		}
		Timer.delay(0.005); // wait for a motor update time
	}
	
	public void testInit(){
		//turnControllerStraight.setPID(SmartDashboard.getNumber("p", kPS), SmartDashboard.getNumber("i", kIS),SmartDashboard.getNumber("d", kDS));
		turnControllerRotate.setSetpoint(-135);
		//turnControllerRotate.setSetpoint(SmartDashboard.getNumber("Rotate SetPoint",turnControllerRotate.getSetpoint()));
		// schedule the autonomous command (example)
		startTime = System.nanoTime();
		startYaw = ahrs.getYaw();
		
		ahrs.reset();
		 
//			 LiveWindow.addActuator("DriveTrain", "FrontLeftMotor", (Talon) RobotMap.driveTrainFrontLeftMotor);	
//			LiveWindow.addActuator("DriveTrain", "FrontRightMotor", (Talon) RobotMap.driveTrainFrontRightMotor);
//			LiveWindow.addActuator("DriveTrain", "RearLeftMotor", (Talon) RobotMap.driveTrainRearLeftMotor);
//			LiveWindow.addActuator("DriveTrain", "RearRightMotor", (Talon) RobotMap.driveTrainRearRightMotor);

		turnControllerStraight.enable();
		turnControllerRotate.disable();
		
//		if(ahrs.getFusedHeading()>180)
//			turnControllerStraight.setSetpoint(ahrs.getFusedHeading()-360);
//		else if(ahrs.getFusedHeading()<-180)
//			turnControllerStraight.setSetpoint(ahrs.getFusedHeading()+360);
//		else
			turnControllerStraight.setSetpoint(0);
//		autoFinished=false;
		//turnControllerRotate.startLiveWindowMode();
		//turnControllerRotate.initTable(turnControllerRotate.getTable());
	//	LiveWindow.setEnabled(true);
	}

	@Override
	public void pidWrite(double output) {
		// TODO Auto-generated method stub

		rotateToAngleRate = output;

	}
}
