// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc5427.basic;

import edu.wpi.first.wpilibj.IterativeRobot;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.command.Scheduler;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj.SPI;
import edu.wpi.first.wpilibj.Timer;

import org.usfirst.frc5427.basic.commands.*;
import org.usfirst.frc5427.basic.subsystems.*;

import com.kauailabs.navx.frc.AHRS;

/**
 * The VM is configured to automatically run this class, and to call the
 * functions corresponding to each mode, as described in the IterativeRobot
 * documentation. If you change the name of this class or the package after
 * creating this project, you must also update the manifest file in the resource
 * directory.
 */
public class Robot extends IterativeRobot implements PIDOutput {

    Command autonomousCommand;

    public static OI oi;
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public static DriveTrain driveTrain;
//    public static DriveWithJoystick driveJoy;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    /**
     * This function is run when the robot is first started up and should be
     * used for any initialization code.
     */
//	public static ADXRS450_Gyro gyro;
	public static AHRS ahrs;
	public static  PIDController turnController;
	public static  PIDController turnController1;
	
	  static  double kP1 = 5f;
	  static  double kI1 = 1f;
	  static  double kD1 = 0.01;
	  static  double kF1 = 0.00;
	  
	  static  double kP = 5f;
	  static  double kI = 1f;
	  static  double kD = 0.01;
	  static  double kF = 0.00;
	  static  double kToleranceDegrees = 0f;
	  double rotateToAngleRate=0;
	//  RobotDrive myRobot;
	

    public void robotInit() {
    RobotMap.init();
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        driveTrain = new DriveTrain();
       
     //   myRobot= new RobotDrive(frontLeftMotor,rearLeftMotor,frontRightMotor,rearRightMotor);
   //     myRobot.setExpiration(0.1);
  	  //ahrs
        try {

            /* Communicate w/navX-MXP via the MXP SPI Bus.                                     */
            /* Alternatively:  I2C.Port.kMXP, SerialPort.Port.kMXP or SerialPort.Port.kUSB     */
            /* See http://navx-mxp.kauailabs.com/guidance/selecting-an-interface/ for details. */
            ahrs = new AHRS(SPI.Port.kMXP) {
            	@Override
            	public double pidGet() {
            		
            		return getFusedHeading();
            	}
            }; 
            
        } catch (RuntimeException ex ) {
     //     Log.debug("Error instantiating navX-MXP:  " + ex.getMessage());
        }
        
        turnController = new PIDController(kP, kI, kD, kF, ahrs, this);
        turnController.setInputRange(-180.0f,  180.0f);                  
        turnController.setOutputRange(-1.0, 1.0);                      
        turnController.setAbsoluteTolerance(kToleranceDegrees);        
        turnController.setContinuous(true);                           
        
     
       
        SmartDashboard.putNumber("p", kP );
        SmartDashboard.putNumber("i", kI );
        SmartDashboard.putNumber("d", kD);
        SmartDashboard.putNumber("f", kF );
        SmartDashboard.putNumber("toleranceDegrees", kToleranceDegrees);
        

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        // OI must be constructed after subsystems. If the OI creates Commands
        //(which it very likely will), subsystems are not guaranteed to bet
        // constructed yet. Thus, their requires() statements may grab null
        // pointers. Bad news. Don't move it.
        oi = new OI();

        // instantiate the command used for the autonomous period
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS

        autonomousCommand = new AutonomousCommand();
//        driveJoy= new DriveWithJoystick();

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
    }

    /**
     * This function is called when the disabled button is hit.
     * You can use it to reset subsystems before shutting down.
     */
    public void disabledInit(){

    }

    public void disabledPeriodic() {
        Scheduler.getInstance().run();
    }
public float startFusedHeading=0;
    public void autonomousInit() {
    	turnController.setPID(SmartDashboard.getNumber("p", kP), SmartDashboard.getNumber("i", kI), SmartDashboard.getNumber("d", kP));
  
        // schedule the autonomous command (example)
    	 startTime = System.nanoTime();
//    	 ahrs.reset();
    	
    	 turnController.enable();
    	
    	 startFusedHeading= ahrs.getFusedHeading();
    	 turnController.setSetpoint(ahrs.getFusedHeading()-360);
//    	 turnController.get();
    	 
    }

    /**
     * This function is called periodically during autonomous
     */
    public long startTime;
    public void autonomousPeriodic() {
        Scheduler.getInstance().run();
        
	     driveTrain.robotDrive41.setSafetyEnabled(true);
	     
//	     if(3>(System.nanoTime()-startTime)/1000000000)
//	     driveTrain.robotDrive41.drive(-.3,0);
//	      while (isEnabled()) {
	        
//	          if (oi.getJoy().getRawButton(1)) {
//	              ahrs.reset();
//	          }
//	          if ( oi.getJoy().getRawButton(2)) {
//	              turnController.setSetpoint(0.0f);
//	              rotateToAngle = true;
//	          } else if ( oi.getJoy().getRawButton(3)) {
//	              turnController.setSetpoint(90.0f);
//	              rotateToAngle = true;
//	          } else if ( oi.getJoy().getRawButton(4)) {
//	              turnController.setSetpoint(179.9f);
//	              rotateToAngle = true;
//	          } else if ( oi.getJoy().getRawButton(5)) {
//	              turnController.setSetpoint(-90.0f);
//	              rotateToAngle = true;
//	          }
	      
           
	          try {
	              /* Use the joystick X axis for lateral movement,          */
	              /* Y axis for forward movement, and the current           */
	              /* calculated rotation rate (or joystick Z axis),         */
	              /* depending upon whether "rotate to angle" is active.    */
	        
	        	  	if(2.3>((System.nanoTime()-startTime)/1000000000f))
	        	  	{
	        	  		driveTrain.robotDrive41.drive( -.3, ahrs.getFusedHeading());
	        	  		
	        	  		SmartDashboard.putBoolean("isConnected", ahrs.isConnected());
	        	  		SmartDashboard.putNumber("CompassHeading",ahrs.getCompassHeading());
	        	  		SmartDashboard.putNumber("How much did Robot move?: ",ahrs.getFusedHeading()-startFusedHeading);
	        	  		SmartDashboard.putNumber("Angle", ahrs.getYaw());
	        	  		SmartDashboard.putNumber("fusedHeading", ahrs.getFusedHeading());
	        	  		SmartDashboard.putBoolean("isCalibrating",ahrs.isCalibrating());
	        	  		SmartDashboard.putString("FirmwareVersion", ahrs.getFirmwareVersion());
	        	  		SmartDashboard.putNumber("UpdateCount", ahrs.getUpdateCount());
	        	  	
	        	  		SmartDashboard.putNumber("FrontLeft",RobotMap.driveTrainFrontLeftMotor.get());
	        	  		SmartDashboard.putNumber("FrontRight",RobotMap.driveTrainFrontRightMotor.get());
	        	  		SmartDashboard.putNumber("RearLeft",RobotMap.driveTrainRearLeftMotor.get());
	        	  		SmartDashboard.putNumber("RearRight",RobotMap.driveTrainRearRightMotor.get());
	        	  		
	        	  		
	        	  		SmartDashboard.putNumber("Yaw", ahrs.getYaw());
	        	  		SmartDashboard.putNumber("SetPoint",turnController.getSetpoint());
	        	  	}
	        	  	else if(5>((System.nanoTime()-startTime)/1000000000f))
	        	  	{
	        	  		driveTrain.robotDrive41.drive( rotateToAngleRate, 90);
	        	  	}
	        	  
	          } catch( RuntimeException ex ) {
	         //   Log.debug("Error communicating with drive system:  " + ex.getMessage());
	        	  
	          }
	          Timer.delay(0.005);		// wait for a motor update time
	      }
    

    public void teleopInit() {
        // This makes sure that the autonomous stops running when
        // teleop starts running. If you want the autonomous to
        // continue until interrupted by another command, remove
        // this line or comment it out.
        if (autonomousCommand != null) autonomousCommand.cancel();
    }

    /**
     * This function is called periodically during operator control
     */
    public void teleopPeriodic() {
        Scheduler.getInstance().run();
       
      
    }

    /**
     * This function is called periodically during test mode
     */
    public void testPeriodic() {
        LiveWindow.run();
    }

	@Override
	public void pidWrite(double output) {
		// TODO Auto-generated method stub
		
		      rotateToAngleRate = output;
		  
		
	}
}
